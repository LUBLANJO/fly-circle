<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="description" content="Play the classic Flappy Bird game online for free. Choose your difficulty: Easy, Medium, Hard, or Nightmare.">
    <title>Fly Ball</title>
    <link rel="icon" type="image/x-icon" href="ball.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        /* --- Base Styles --- */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #6ab0de, #b0e0f6, #ffb6c1);
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            aspect-ratio: 4 / 3; /* Maintains 4:3 ratio */
            max-height: 90vh; /* Caps height based on viewport */
            overflow: hidden;
            border: 8px solid #5a4b3c;
            border-radius: 15px;
            background: url('background.jpg') no-repeat center/cover;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3), inset 0 0 10px rgba(0,0,0,0.2);
            touch-action: manipulation;
        }

        /* --- Ball (using ball.jfif) --- */
        #bird {
            position: absolute;
            width: 5%;
            aspect-ratio: 1 / 1;
            min-width: 30px;
            background: url('ball.png') no-repeat center/contain; /* External ball image */
            border-radius: 50%; /* Circular shape */
            left: 25%;
            top: 50%;
            transition: transform 0.1s ease-out;
            z-index: 5;
        }
        #bird.fallback {
            background: blue;
            border-radius: 50%;
        }
        #bird.invincible {
            box-shadow: 0 0 15px 8px rgba(255, 255, 0, 0.7);
            animation: invinciblePulse 1s infinite;
        }

        /* --- Pipes --- */
        .pipe {
            background: linear-gradient(90deg, var(--pipe-start), var(--pipe-end));
            border: 2px solid var(--pipe-border);
            border-radius: 8px;
            position: absolute;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.4), 1px 1px 4px rgba(0, 0, 0, 0.2);
            z-index: 2;
            animation: slideIn 0.3s ease-out;
        }
        .pipe-top::before,
        .pipe-bottom::before {
            content: '';
            position: absolute;
            left: 0;
            width: 100%;
            height: 5%;
            background: linear-gradient(to bottom, var(--pipe-cap-start), var(--pipe-start));
            border: 2px solid var(--pipe-border);
            border-radius: 6px 6px 0 0;
        }
        .pipe-top::before { top: -5%; }
        .pipe-bottom::before { bottom: -5%; border-radius: 0 0 6px 6px; }

        :root {
            --pipe-start: #ff6666;
            --pipe-end: #ff3333;
            --pipe-cap-start: #ff9999;
            --pipe-border: #800000;
        }
        body.medium .pipe { --pipe-start: #ff4d4d; --pipe-end: #cc2929; --pipe-cap-start: #ff8080; }
        body.hard .pipe { --pipe-start: #ff3333; --pipe-end: #b30000; --pipe-cap-start: #ff6666; }
        body.nightmare .pipe { --pipe-start: #cc0000; --pipe-end: #990000; --pipe-cap-start: #ff3333; }

        /* --- UI Elements --- */
        #score, #scoreboard {
            position: absolute;
            top: 2%;
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(12px, 2.5vw, 20px);
            color: white;
            text-shadow: 1px 1px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000;
            z-index: 10;
        }
        #score { left: 2%; }
        #scoreboard { right: 15%; }

        #pause-button {
            position: absolute;
            top: 2%;
            right: 2%;
            font-size: clamp(10px, 2vw, 14px);
            padding: 0.5em 1em;
            background: linear-gradient(45deg, #ff6b6b, #f0935d);
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            z-index: 10;
            transition: transform 0.2s ease;
        }
        #pause-button:hover, #pause-button:focus { transform: scale(1.05); }
        #pause-button:active { transform: scale(0.95); }

        /* --- Screens --- */
        #start-screen, #game-over-screen, #pause-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            padding: 5%;
            box-sizing: border-box;
            color: white;
            text-align: center;
        }
        #pause-screen, #game-over-screen { display: none; }

        #start-screen h2, #game-over-screen h2, #pause-screen h2 {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(18px, 4vw, 28px);
            margin: 2% 0;
            padding: 2%;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000;
            width: 90%;
            animation: color-cycle 10s infinite linear;
        }

        #leaderboard, #achievements, #tips, #final-score, #pause-score {
            font-size: clamp(10px, 2vw, 16px);
            margin: 2% 0;
            width: 90%;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        #leaderboard h3, #achievements h3 {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(12px, 2.2vw, 18px);
            margin-bottom: 1%;
        }
        #tips { line-height: 1.4; }

        /* --- Buttons --- */
        .button {
            padding: 0.8em 1.5em;
            margin: 1% 0.5%;
            font-size: clamp(12px, 2.5vw, 16px);
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            border: none;
            border-radius: 25px;
            background: linear-gradient(45deg, #ff6b6b, #f0935d);
            color: white;
            text-transform: uppercase;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 3px 8px rgba(0,0,0,0.2);
        }
        .button:hover, .button:focus {
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0,0,0,0.3);
        }
        .button:active { transform: scale(0.98); }

        /* --- Notification --- */
        #notification {
            position: absolute;
            top: 1%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 215, 0, 0.95);
            color: #333;
            padding: 0.5em 1em;
            border-radius: 10px;
            font-size: clamp(10px, 2vw, 16px);
            z-index: 50;
            display: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        /* --- Animations --- */
        @keyframes slideIn {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes invinciblePulse {
            0% { box-shadow: 0 0 15px 8px rgba(255, 255, 0, 0.7); }
            50% { box-shadow: 0 0 20px 10px rgba(255, 255, 100, 0.9); }
            100% { box-shadow: 0 0 15px 8px rgba(255, 255, 0, 0.7); }
        }
        @keyframes color-cycle {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }

        /* --- Media Queries --- */
        @media (max-width: 600px) {
            #game-container { border-width: 5px; }
            #bird { min-width: 25px; }
            #score, #scoreboard { font-size: clamp(10px, 2vw, 14px); }
            #pause-button { padding: 0.4em 0.8em; font-size: clamp(8px, 1.8vw, 12px); }
            .button { padding: 0.6em 1.2em; font-size: clamp(10px, 2vw, 14px); }
            #start-screen h2, #game-over-screen h2, #pause-screen h2 { font-size: clamp(16px, 3.5vw, 24px); }
        }
    </style>
</head>
<body>
    <div id="game-container" role="main">
        <div id="bird" role="img" aria-label="Flappy Ball"></div>
        <div id="score" aria-live="polite">Score: 0</div>
        <div id="scoreboard" aria-live="polite">Pipes: 0</div>
        <button id="pause-button" onclick="togglePause()" aria-label="Pause Game">Pause</button>
        <div id="notification" aria-live="assertive"></div>

        <div id="start-screen" role="dialog" aria-label="Start Menu">
            <h2>Fly Ball</h2>
            <div id="leaderboard">Loading High Scores...</div>
            <div id="achievements">Loading Achievements...</div>
            <div id="tips">Controls: Spacebar, Click, or Tap to jump. Ctrl+P or Esc to pause/resume. Avoid pipes!</div>
            <div class="button-group">
                <button class="button" id="easy-btn" onclick="startGame('easy')" tabindex="0">Easy</button>
                <button class="button" id="medium-btn" onclick="startGame('medium')" tabindex="0">Medium</button>
                <button class="button" id="hard-btn" onclick="startGame('hard')" tabindex="0">Hard</button>
                <button class="button" id="nightmare-btn" onclick="startGame('nightmare')" style="display: none;" tabindex="0">Nightmare</button>
            </div>
            <button class="button" onclick="resetHighScores()" style="background: linear-gradient(45deg, #888, #666);" tabindex="0">Reset Scores</button>
        </div>

        <div id="pause-screen" role="dialog" aria-label="Pause Menu">
            <h2>Paused</h2>
            <div id="pause-score" aria-live="polite">Score: 0</div>
            <div class="button-group">
                <button class="button" onclick="togglePause()" tabindex="0">Resume</button>
                <button class="button" onclick="retryGame()" tabindex="0">Restart</button>
                <button class="button" onclick="quitToMenu()" tabindex="0">Menu</button>
            </div>
        </div>

        <div id="game-over-screen" role="dialog" aria-label="Game Over Menu">
            <h2>Game Over</h2>
            <div id="final-score" aria-live="polite">Final Score: 0</div>
            <div class="button-group">
                <button class="button" onclick="retryGame()" tabindex="0">Retry</button>
                <button class="button" onclick="quitToMenu()" style="background: linear-gradient(45deg, #aaa, #888);" tabindex="0">Menu</button>
            </div>
        </div>
    </div>

    <audio id="kick-sound" src="kick.mp3" preload="auto"></audio>
    <audio id="pipe-sound" src="pipe.mp3" preload="auto"></audio>
    <audio id="game-over-sound" src="gameover.mp3" preload="auto"></audio>
    <audio id="power-up-sound" src="powerup.mp3" preload="auto"></audio>
    <audio id="bg-music" src="bgmusic.mp3" loop preload="auto"></audio>

    <script>
        const gameContainer = document.getElementById('game-container');
        const bird = document.getElementById('bird');
        const scoreDisplay = document.getElementById('score');
        const scoreboard = document.getElementById('scoreboard');
        const pauseButton = document.getElementById('pause-button');
        const startScreen = document.getElementById('start-screen');
        const pauseScreen = document.getElementById('pause-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScore = document.getElementById('final-score');
        const leaderboard = document.getElementById('leaderboard');
        const achievementsDisplay = document.getElementById('achievements');
        const notification = document.getElementById('notification');
        const nightmareBtn = document.getElementById('nightmare-btn');
        const pauseScore = document.getElementById('pause-score');
        const kickSound = document.getElementById('kick-sound');
        const pipeSound = document.getElementById('pipe-sound');
        const gameOverSound = document.getElementById('game-over-sound');
        const powerUpSound = document.getElementById('power-up-sound');
        const bgMusic = document.getElementById('bg-music');

        let birdY, velocity = 0, score = 0, pipeCount = 0;
        let pipes = [], clouds = [], powerUps = [], trails = [];
        let gameOver = false, gameStarted = false, isPaused = false;
        let levelConfig = {}, pipeSpawnInterval, cloudSpawnInterval, powerUpSpawnInterval, gameLoopId;
        let multiplier = 1, isTutorial = !localStorage.getItem('hasPlayed'), lastMilestoneScore = 0;
        let isInvincible = false, invincibilityTimer = null;

        const BIRD_SIZE = () => Math.max(gameContainer.clientWidth * 0.05, 30);
        const POWERUP_SIZE = 30;
        const PIPE_WIDTHS = [50, 60, 70];
        const MIN_HORIZONTAL_GAP = 200;
        const MAX_HORIZONTAL_GAP = 300;

        const levels = {
            easy:      { gravity: 0.6, jump: -10, baseSpeed: 3.0, pipeFreq: 2000, powerUpChance: 0.15, verticalGap: 180 },
            medium:    { gravity: 0.7, jump: -11, baseSpeed: 3.5, pipeFreq: 1800, powerUpChance: 0.20, verticalGap: 160 },
            hard:      { gravity: 0.8, jump: -12, baseSpeed: 4.0, pipeFreq: 1600, powerUpChance: 0.25, verticalGap: 140 },
            nightmare: { gravity: 0.9, jump: -13, baseSpeed: 4.5, pipeFreq: 1500, powerUpChance: 0.30, verticalGap: 120 }
        };

        const GAME_WIDTH = () => gameContainer.clientWidth;
        const GAME_HEIGHT = () => gameContainer.clientHeight;

        let highScores = JSON.parse(localStorage.getItem('flappyHighScores')) || { easy: 0, medium: 0, hard: 0, nightmare: 0 };
        let achievements = JSON.parse(localStorage.getItem('achievements')) || [];

        function updateLeaderboard() {
            leaderboard.innerHTML = `<h3>High Scores:</h3>Easy: ${highScores.easy}<br>Medium: ${highScores.medium}<br>Hard: ${highScores.hard}<br>Nightmare: ${highScores.nightmare}`;
            nightmareBtn.style.display = highScores.hard >= 40 ? 'inline-block' : 'none';
            achievementsDisplay.innerHTML = `<h3>Achievements:</h3>${achievements.length > 0 ? achievements.join(', ') : 'None yet!'}`;
        }

        function resetHighScores() {
            if (confirm("Reset all scores and achievements?")) {
                highScores = { easy: 0, medium: 0, hard: 0, nightmare: 0 };
                achievements = [];
                localStorage.setItem('flappyHighScores', JSON.stringify(highScores));
                localStorage.setItem('achievements', JSON.stringify(achievements));
                localStorage.removeItem('hasPlayed');
                isTutorial = true;
                updateLeaderboard();
                showNotification("Scores Reset!");
            }
        }

        function showNotification(message) {
            notification.textContent = message;
            notification.style.display = 'block';
            clearTimeout(notification.timeoutId);
            notification.timeoutId = setTimeout(() => {
                notification.style.display = 'none';
                notification.timeoutId = null;
            }, 3000);
        }

        function startGame(level) {
            if (!levels[level]) return;

            levelConfig = { ...levels[level], name: level };
            document.body.className = level;
            birdY = GAME_HEIGHT() * 0.5;
            velocity = 0;
            score = 0;
            pipeCount = 0;
            multiplier = 1;
            lastMilestoneScore = 0;
            gameOver = false;
            isPaused = false;
            gameStarted = true;
            isInvincible = false;
            if (invincibilityTimer) clearTimeout(invincibilityTimer);
            bird.classList.remove('invincible');

            clearGameElements();

            scoreDisplay.textContent = `Score: ${score}`;
            scoreboard.textContent = `Pipes: ${pipeCount}`;
            bird.style.top = birdY + 'px';
            bird.style.transform = 'rotate(0deg)';
            bird.style.display = 'block';
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            pauseScreen.style.display = 'none';
            pauseButton.style.display = 'block';

            clearInterval(pipeSpawnInterval);
            clearInterval(cloudSpawnInterval);
            clearInterval(powerUpSpawnInterval);
            cancelAnimationFrame(gameLoopId);

            pipeSpawnInterval = setInterval(createPipePair, levelConfig.pipeFreq);
            cloudSpawnInterval = setInterval(createCloud, 5000);
            powerUpSpawnInterval = setInterval(spawnPowerUp, 4000);

            bgMusic.currentTime = 0;
            bgMusic.play().catch(() => {});

            gameLoop();

            if (isTutorial) {
                localStorage.setItem('hasPlayed', 'true');
                isTutorial = false;
            }
        }

        function clearGameElements() {
            pipes.forEach(p => p.element.remove());
            pipes = [];
            clouds.forEach(c => c.element.remove());
            clouds = [];
            powerUps.forEach(p => p.element.remove());
            powerUps = [];
            trails.forEach(t => t.remove());
            trails = [];
        }

        function updateBird() {
            if (!gameStarted || gameOver || isPaused) return;

            const gameHeight = GAME_HEIGHT();
            const dynamicGravity = Math.min(levelConfig.gravity + (score * 0.001), levelConfig.gravity * 1.5);
            velocity += dynamicGravity;
            birdY += velocity;

            birdY = Math.max(0, Math.min(birdY, gameHeight - BIRD_SIZE()));
            bird.style.top = birdY + 'px';

            const rotation = Math.max(-30, Math.min(velocity * 3, 90));
            bird.style.transform = `rotate(${rotation}deg)`;

            if (birdY <= 0 || birdY >= gameHeight - BIRD_SIZE()) endGame();
            if (Math.random() < 0.15) createTrail();
        }

        function createTrail() {
            if (trails.length > 10) {
                const oldest = trails.shift();
                oldest?.remove();
            }

            const trail = document.createElement('div');
            trail.className = 'trail';
            trail.style.left = (bird.offsetLeft + BIRD_SIZE() / 2 - 4) + 'px';
            trail.style.top = (bird.offsetTop + BIRD_SIZE() / 2 - 4) + 'px';
            gameContainer.appendChild(trail);
            trails.push(trail);

            setTimeout(() => {
                const index = trails.indexOf(trail);
                if (index > -1) trails.splice(index, 1);
                trail.remove();
            }, 500);
        }

        function createPipePair() {
            if (!gameStarted || gameOver || isPaused) return;

            const gameHeight = GAME_HEIGHT();
            const gameWidth = GAME_WIDTH();
            const pipeWidth = PIPE_WIDTHS[Math.floor(Math.random() * PIPE_WIDTHS.length)];
            const currentVerticalGap = levelConfig.verticalGap;

            const minTopHeight = gameHeight * 0.1;
            const maxTopHeight = gameHeight - currentVerticalGap - minTopHeight;
            const topPipeHeight = Math.floor(Math.random() * (maxTopHeight - minTopHeight)) + minTopHeight;
            const bottomPipeHeight = gameHeight - topPipeHeight - currentVerticalGap;

            let startX = gameWidth;
            if (pipes.length) {
                const lastPipe = pipes[pipes.length - 1];
                const complexityFactor = Math.min(score / 100, 0.5);
                const horizontalGap = MIN_HORIZONTAL_GAP + (Math.random() * (MAX_HORIZONTAL_GAP - MIN_HORIZONTAL_GAP) * (1 - complexityFactor));
                startX = Math.max(startX, lastPipe.x + pipeWidth + horizontalGap);
            }

            const topPipe = document.createElement('div');
            topPipe.className = 'pipe pipe-top';
            topPipe.style.height = topPipeHeight + 'px';
            topPipe.style.width = pipeWidth + 'px';
            topPipe.style.left = startX + 'px';
            topPipe.style.top = '0';
            gameContainer.appendChild(topPipe);
            pipes.push({ element: topPipe, x: startX, y: 0, height: topPipeHeight, width: pipeWidth, isTop: true, passed: false });

            const bottomPipe = document.createElement('div');
            bottomPipe.className = 'pipe pipe-bottom';
            bottomPipe.style.height = bottomPipeHeight + 'px';
            bottomPipe.style.width = pipeWidth + 'px';
            bottomPipe.style.left = startX + 'px';
            bottomPipe.style.bottom = '0';
            gameContainer.appendChild(bottomPipe);
            const bottomPipeY = gameHeight - bottomPipeHeight;
            pipes.push({ element: bottomPipe, x: startX, y: bottomPipeY, height: bottomPipeHeight, width: pipeWidth, isTop: false, passed: false });
        }

        function createCloud() {
            if (clouds.length > 5 || Math.random() > 0.4) return;

            const cloud = document.createElement('div');
            cloud.className = 'cloud';
            cloud.style.width = '60px';
            cloud.style.height = '30px';
            cloud.style.background = 'linear-gradient(to bottom, #f8f9fa, #e9ecef)';
            cloud.style.borderRadius = '15px';
            cloud.style.left = GAME_WIDTH() + 'px';
            cloud.style.top = (Math.random() * (GAME_HEIGHT() * 0.6)) + 'px';
            cloud.style.opacity = 0.5 + Math.random() * 0.3;
            gameContainer.appendChild(cloud);
            clouds.push({ element: cloud, x: GAME_WIDTH(), speedFactor: 0.3 + Math.random() * 0.4 });
        }

        function doesYOverlapWithPipes(yPosition, targetX) {
            const powerUpTop = yPosition;
            const powerUpBottom = yPosition + POWERUP_SIZE;

            for (const pipe of pipes) {
                if (pipe.x < targetX + pipe.width && pipe.x + pipe.width > targetX - POWERUP_SIZE) {
                    const pipeTop = pipe.isTop ? 0 : pipe.y;
                    const pipeBottom = pipe.isTop ? pipe.height : pipe.y + pipe.height;
                    if (powerUpBottom > pipeTop && powerUpTop < pipeBottom) return true;
                }
            }
            return false;
        }

        function spawnPowerUp() {
            if (!gameStarted || gameOver || isPaused || powerUps.length || Math.random() > levelConfig.powerUpChance) return;

            const gameHeight = GAME_HEIGHT();
            const gameWidth = GAME_WIDTH();
            const spawnX = gameWidth + 50;

            let attempts = 0;
            const maxAttempts = 10;

            while (attempts++ < maxAttempts) {
                let targetPipe = null;
                for (const pipe of pipes) {
                    if (pipe.isTop && pipe.x < spawnX + 100 && pipe.x + pipe.width > spawnX - 100) {
                        targetPipe = pipe;
                        break;
                    }
                }

                if (targetPipe) {
                    const topPipeBottom = targetPipe.height;
                    const bottomPipeTop = gameHeight - (gameHeight - topPipeBottom - levelConfig.verticalGap);
                    const gapCenter = topPipeBottom + (bottomPipeTop - topPipeBottom) / 2;
                    const spawnY = gapCenter - POWERUP_SIZE / 2;

                    if (spawnY > POWERUP_SIZE && spawnY < gameHeight - POWERUP_SIZE && !doesYOverlapWithPipes(spawnY, spawnX)) {
                        const powerUp = document.createElement('div');
                        powerUp.className = 'power-up';
                        powerUp.style.width = POWERUP_SIZE + 'px';
                        powerUp.style.height = POWERUP_SIZE + 'px';
                        powerUp.style.background = 'radial-gradient(circle, #ffd700, #ffa500)';
                        powerUp.style.border-radius = '50%';
                        powerUp.style.left = spawnX + 'px';
                        powerUp.style.top = spawnY + 'px';
                        gameContainer.appendChild(powerUp);
                        powerUps.push({ element: powerUp, x: spawnX, y: spawnY, type: 'invincible' });
                        return;
                    }
                }

                const minY = gameHeight * 0.2;
                const maxY = gameHeight * 0.8 - POWERUP_SIZE;
                const spawnY = Math.random() * (maxY - minY) + minY;
                if (!doesYOverlapWithPipes(spawnY, spawnX)) {
                    const powerUp = document.createElement('div');
                    powerUp.className = 'power-up';
                    powerUp.style.width = POWERUP_SIZE + 'px';
                    powerUp.style.height = POWERUP_SIZE + 'px';
                    powerUp.style.background = 'radial-gradient(circle, #ffd700, #ffa500)';
                    powerUp.style.border-radius = '50%';
                    powerUp.style.left = spawnX + 'px';
                    powerUp.style.top = spawnY + 'px';
                    gameContainer.appendChild(powerUp);
                    powerUps.push({ element: powerUp, x: spawnX, y: spawnY, type: 'invincible' });
                    return;
                }
            }
        }

        function updateObstacles() {
            if (isPaused || gameOver) return;

            const speed = levelConfig.baseSpeed;

            const birdRect = bird.getBoundingClientRect();
            const gameRect = gameContainer.getBoundingClientRect();
            const birdRadius = BIRD_SIZE() * 0.4;
            const birdCenterX = (birdRect.left - gameRect.left) + birdRect.width / 2;
            const birdCenterY = (birdRect.top - gameRect.top) + birdRect.height / 2;

            for (let i = pipes.length - 1; i >= 0; i--) {
                const pipe = pipes[i];
                pipe.x -= speed;
                pipe.element.style.left = pipe.x + 'px';

                if (!isInvincible && checkCollision(birdCenterX, birdCenterY, birdRadius, pipe)) {
                    endGame();
                    return;
                }

                if (!pipe.passed && pipe.isTop && birdCenterX > pipe.x + pipe.width) {
                    pipe.passed = true;
                    const bottomPipe = pipes.find(p => p.x === pipe.x && !p.isTop);
                    if (bottomPipe) bottomPipe.passed = true;
                    pipeCount++;
                    multiplier = pipeCount >= 50 ? 4 : pipeCount >= 25 ? 3 : pipeCount >= 10 ? 2 : 1;
                    score += multiplier;

                    if (score >= lastMilestoneScore + 100) {
                        lastMilestoneScore = Math.floor(score / 100) * 100;
                        showNotification(`Milestone: ${lastMilestoneScore}!`);
                    }

                    scoreDisplay.textContent = `Score: ${score}`;
                    scoreboard.textContent = `Pipes: ${pipeCount}`;
                    pipeSound.play().catch(() => {});
                    checkAchievements();
                }

                if (pipe.x + pipe.width < 0) {
                    pipe.element.remove();
                    pipes.splice(i, 1);
                }
            }

            for (let i = clouds.length - 1; i >= 0; i--) {
                const cloud = clouds[i];
                cloud.x -= speed * cloud.speedFactor;
                cloud.element.style.left = cloud.x + 'px';
                if (cloud.x + cloud.element.offsetWidth < 0) {
                    cloud.element.remove();
                    clouds.splice(i, 1);
                }
            }

            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                powerUp.x -= speed;
                powerUp.element.style.left = powerUp.x + 'px';

                const powerUpCenterX = powerUp.x + POWERUP_SIZE / 2;
                const powerUpCenterY = powerUp.y + POWERUP_SIZE / 2;
                const distance = Math.sqrt((birdCenterX - powerUpCenterX) ** 2 + (birdCenterY - powerUpCenterY) ** 2);

                if (distance < birdRadius + POWERUP_SIZE / 2) {
                    powerUpSound.play().catch(() => {});
                    applyPowerUp(powerUp.type);
                    powerUp.element.remove();
                    powerUps.splice(i, 1);
                } else if (powerUp.x + POWERUP_SIZE < 0) {
                    powerUp.element.remove();
                    powerUps.splice(i, 1);
                }
            }
        }

        function checkCollision(birdX, birdY, birdR, pipe) {
            const closestX = Math.max(pipe.x, Math.min(birdX, pipe.x + pipe.width));
            const closestY = Math.max(pipe.y, Math.min(birdY, pipe.y + pipe.height));
            const distanceSquared = (birdX - closestX) ** 2 + (birdY - closestY) ** 2;
            return distanceSquared < (birdR * birdR);
        }

        function applyPowerUp(type) {
            if (type === 'invincible' && !isInvincible) {
                isInvincible = true;
                bird.classList.add('invincible');
                showNotification("Invincible!");
                if (invincibilityTimer) clearTimeout(invincibilityTimer);
                invincibilityTimer = setTimeout(() => {
                    isInvincible = false;
                    bird.classList.remove('invincible');
                    showNotification("Invincibility Ended!");
                    invincibilityTimer = null;
                }, 5000);
            }
        }

        function checkAchievements() {
            let newAchievement = false;
            const achieve = (name) => {
                if (!achievements.includes(name)) {
                    achievements.push(name);
                    showNotification(`Achievement: ${name}!`);
                    newAchievement = true;
                }
            };

            if (pipeCount >= 10) achieve('First 10 Pipes');
            if (score >= 50) achieve('Score 50+');
            if (levelConfig.name === 'nightmare' && score >= 25) achieve('Nightmare Survivor');

            if (newAchievement) {
                localStorage.setItem('achievements', JSON.stringify(achievements));
                updateLeaderboard();
            }
        }

        function jump() {
            if (!gameStarted || gameOver || isPaused) return;
            velocity = levelConfig.jump;
            kickSound.play().catch(() => {});
            bird.style.transform = `rotate(-30deg)`;
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                jump();
            } else if ((e.ctrlKey || e.metaKey) && e.code === 'KeyP' || e.code === 'Escape') {
                e.preventDefault();
                if (gameStarted && !gameOver) togglePause();
            }
        });

        function gameLoop() {
            if (gameOver) return;
            if (!isPaused) {
                updateBird();
                if (!gameOver) updateObstacles();
            }
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function togglePause() {
            if (!gameStarted || gameOver) return;

            isPaused = !isPaused;
            pauseButton.textContent = isPaused ? 'Resume' : 'Pause';
            pauseScreen.style.display = isPaused ? 'flex' : 'none';

            if (isPaused) {
                pauseScore.textContent = `Score: ${score}`;
                bgMusic.pause();
                cancelAnimationFrame(gameLoopId);
                clearInterval(pipeSpawnInterval);
                clearInterval(cloudSpawnInterval);
                clearInterval(powerUpSpawnInterval);
                if (invincibilityTimer) clearTimeout(invincibilityTimer);
            } else {
                bgMusic.play().catch(() => {});
                pipeSpawnInterval = setInterval(createPipePair, levelConfig.pipeFreq);
                cloudSpawnInterval = setInterval(createCloud, 5000);
                powerUpSpawnInterval = setInterval(spawnPowerUp, 4000);
                if (isInvincible && !invincibilityTimer) {
                    invincibilityTimer = setTimeout(() => {
                        isInvincible = false;
                        bird.classList.remove('invincible');
                        showNotification("Invincibility Ended!");
                        invincibilityTimer = null;
                    }, 5000);
                }
                if (!gameLoopId) {
                    gameLoop();
                }
            }
        }

        function endGame() {
            if (gameOver) return;

            gameOver = true;
            gameStarted = false;
            isInvincible = false;
            if (invincibilityTimer) clearTimeout(invincibilityTimer);
            bird.classList.remove('invincible');

            clearInterval(pipeSpawnInterval);
            clearInterval(cloudSpawnInterval);
            clearInterval(powerUpSpawnInterval);
            cancelAnimationFrame(gameLoopId);

            gameOverSound.play().catch(() => {});
            bgMusic.pause();

            gameOverScreen.style.display = 'flex';
            finalScore.textContent = `Final Score: ${score}`;
            pauseButton.style.display = 'none';

            const currentLevel = levelConfig.name || 'easy';
            if (score > (highScores[currentLevel] || 0)) {
                highScores[currentLevel] = score;
                localStorage.setItem('flappyHighScores', JSON.stringify(highScores));
                updateLeaderboard();
                showNotification(`New High Score: ${currentLevel}!`);
            }
        }

        function retryGame() {
            gameOverScreen.style.display = 'none';
            pauseScreen.style.display = 'none';
            cancelAnimationFrame(gameLoopId);
            startGame(levelConfig.name || 'easy');
        }

        function quitToMenu() {
            gameOver = true;
            gameStarted = false;
            isPaused = false;
            isInvincible = false;
            if (invincibilityTimer) clearTimeout(invincibilityTimer);
            bird.classList.remove('invincible');
            cancelAnimationFrame(gameLoopId);
            clearInterval(pipeSpawnInterval);
            clearInterval(cloudSpawnInterval);
            clearInterval(powerUpSpawnInterval);
            bgMusic.pause();
            bgMusic.currentTime = 0;

            clearGameElements();
            bird.style.display = 'none';
            pauseButton.style.display = 'none';
            document.body.className = '';

            gameOverScreen.style.display = 'none';
            pauseScreen.style.display = 'none';
            startScreen.style.display = 'flex';
            updateLeaderboard();
        }

        window.addEventListener('load', () => {
            updateLeaderboard();
            bird.style.display = 'none';
            pauseButton.style.display = 'none';
            adjustGameSize();
            birdY = GAME_HEIGHT() * 0.5;
            bird.style.top = birdY + 'px';

            // Check if ball image loads, otherwise apply fallback
            const ballImage = new Image();
            ballImage.src = 'ball.jfif';
            ballImage.onerror = () => {
                bird.classList.add('fallback');
            };
        });

        let lastTouchTime = 0;
        function enhanceTouchSupport() {
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

            function handleJump(e) {
                const now = Date.now();
                if (now - lastTouchTime < 200) return; // Debounce touch
                lastTouchTime = now;

                if (!gameStarted || gameOver || isPaused) return;
                const rect = gameContainer.getBoundingClientRect();
                const touchX = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
                const touchY = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;

                // Avoid triggering jump if tapping buttons
                if (touchX > pauseButton.offsetLeft && touchY < pauseButton.offsetHeight + pauseButton.offsetTop) return;

                e.preventDefault();
                jump();
            }

            if (isTouchDevice) {
                gameContainer.addEventListener('touchstart', handleJump, { passive: false });
                gameContainer.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
            } else {
                gameContainer.addEventListener('mousedown', handleJump);
            }
            gameContainer.addEventListener('contextmenu', e => e.preventDefault());
        }
        enhanceTouchSupport();

        function adjustGameSize() {
            const vh = window.innerHeight * 0.9;
            const vw = window.innerWidth * 0.9;
            const aspectRatio = 4 / 3;

            let height = Math.min(vh, vw / aspectRatio);
            let width = height * aspectRatio;

            if (width > vw) {
                width = vw;
                height = width / aspectRatio;
            }

            gameContainer.style.width = `${width}px`;
            gameContainer.style.height = `${height}px`;

            if (!gameStarted) {
                birdY = GAME_HEIGHT() * 0.5;
                bird.style.top = birdY + 'px';
            }
        }

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(adjustGameSize, 100);
        });
        window.addEventListener('orientationchange', adjustGameSize);

        (function handleAudioCompatibility() {
            const audioElements = [bgMusic, kickSound, pipeSound, gameOverSound, powerUpSound];
            let audioUnlocked = false;

            function unlockAudio() {
                if (audioUnlocked) return;
                audioElements.forEach(audio => {
                    audio.play().then(() => audio.pause()).catch(() => {});
                    audio.currentTime = 0;
                });
                audioUnlocked = true;
                document.removeEventListener('touchstart', unlockAudio);
                document.removeEventListener('click', unlockAudio);
            }

            document.addEventListener('touchstart', unlockAudio, { once: true, passive: true });
            document.addEventListener('click', unlockAudio, { once: true, passive: true });
        })();
    </script>
</body>
</html>
