<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content='Play the classic Flappy Bird game online for free. Choose your difficulty: Easy, Medium, Hard, or Nightmare.' name='description'/>
    <title>Flappy Bird</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        /* --- Base Styles --- */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #6ab0de, #b0e0f6, #ffb6c1);
            font-family: 'Poppins', sans-serif;
            overflow: hidden;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #game-container {
            width: 90vw;
            max-width: 800px;
            height: 67.5vw;
            max-height: 600px;
            position: relative;
            overflow: hidden;
            border: 10px solid #5a4b3c;
            border-radius: 20px;
            background: url('background.jpg') no-repeat center/cover;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4), inset 0 0 15px rgba(0,0,0,0.2);
            transition: background-color 3s ease-in-out;
            touch-action: manipulation; /* Improves touch responsiveness */
        }

        /* --- Bird --- */
        #bird {
            width: 40px;
            height: 40px;
            background: url('bird.png') no-repeat center center;
            background-size: contain;
            position: absolute;
            left: 25%;
            top: 46.67%;
            transition: transform 0.1s ease-out;
            z-index: 5;
        }

        #bird.invincible {
            box-shadow: 0 0 20px 10px rgba(255, 255, 0, 0.7);
            animation: invinciblePulse 1s infinite;
        }

        /* --- Pipes --- */
        .pipe {
            background: linear-gradient(90deg, var(--pipe-start), var(--pipe-end));
            border: 3px solid var(--pipe-border);
            border-radius: 10px;
            position: absolute;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5), 2px 2px 5px rgba(0, 0, 0, 0.3);
            z-index: 2;
            animation: slideIn 0.5s ease-out; /* Subtle slide-in animation */
        }
        .pipe-top::before,
        .pipe-bottom::before {
            content: '';
            position: absolute;
            left: 0;
            width: 100%;
            height: 20px;
            background: linear-gradient(to bottom, var(--pipe-cap-start), var(--pipe-start));
            border: 3px solid var(--pipe-border);
            border-radius: 8px 8px 0 0;
        }
        .pipe-top::before {
            top: -23px;
        }
        .pipe-bottom::before {
            bottom: -23px;
            border-radius: 0 0 8px 8px;
        }

        /* Difficulty-specific pipe colors */
        :root {
            --pipe-start: #ff6666; /* Easy */
            --pipe-end: #ff3333;
            --pipe-cap-start: #ff9999;
            --pipe-border: #800000;
        }
        body.medium .pipe { --pipe-start: #ff4d4d; --pipe-end: #cc2929; --pipe-cap-start: #ff8080; }
        body.hard .pipe { --pipe-start: #ff3333; --pipe-end: #b30000; --pipe-cap-start: #ff6666; }
        body.nightmare .pipe { --pipe-start: #cc0000; --pipe-end: #990000; --pipe-cap-start: #ff3333; }

        /* --- Other Elements --- */
        .cloud { /* Unchanged */ }
        .power-up { /* Unchanged */ }
        .trail { /* Unchanged */ }

        #score, #scoreboard {
            position: absolute;
            top: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(16px, 3vw, 24px);
            color: white;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000, 3px 3px 5px rgba(0,0,0,0.7);
            z-index: 10;
        }
        #score { left: 20px; }
        #scoreboard { right: 150px; }

        #pause-button {
            position: absolute;
            top: 20px;
            right: 20px;
            font-family: 'Poppins', sans-serif;
            font-size: clamp(12px, 2.5vw, 16px);
            color: white;
            background: linear-gradient(45deg, #ff6b6b, #f0935d);
            border: none;
            border-radius: 8px;
            padding: 8px 18px;
            cursor: pointer;
            z-index: 10;
            transition: transform 0.2s ease, filter 0.2s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #pause-button:hover { transform: scale(1.05); filter: brightness(1.1); }
        #pause-button:active { transform: scale(0.98); filter: brightness(0.95); }

        /* --- Screens --- */
        #start-screen, #game-over-screen, #pause-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
            color: white;
        }
        #pause-screen, #game-over-screen { display: none; }

        #start-screen h2, #game-over-screen h2, #pause-screen h2 {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(24px, 5vw, 36px);
            margin: 10px 0;
            padding: 10px;
            text-shadow: 3px 3px 0 #000, -3px -3px 0 #000, 3px -3px 0 #000, -3px 3px 0 #000, 5px 5px 8px rgba(0,0,0,0.7);
            width: 90%;
            animation: color-cycle 10s infinite linear;
            z-index: 21;
        }

        /* --- Buttons --- */
        .button {
            padding: 12px 28px;
            margin: 10px 5px;
            font-size: clamp(14px, 3vw, 18px);
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            background: linear-gradient(45deg, #ff6b6b, #f0935d);
            color: white;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease, filter 0.2s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            display: inline-block;
            -webkit-appearance: none;
            appearance: none;
            outline: none;
        }
        .button:hover, .button:focus {
            transform: translateY(-2px) scale(1.03);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
            filter: brightness(1.1);
        }
        .button:active {
            transform: translateY(0px) scale(0.98);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            filter: brightness(0.95);
        }

        /* --- Animations --- */
        @keyframes slideIn {
            from { transform: translateX(50px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes powerupPulse { /* Unchanged */ }
        @keyframes fadeOut { /* Unchanged */ }
        @keyframes color-cycle { /* Unchanged */ }
        @keyframes invinciblePulse { /* Unchanged */ }

        /* --- Responsive Design --- */
        @media (max-width: 480px) {
            #score, #scoreboard { font-size: 14px; }
            #pause-button { padding: 6px 12px; font-size: 12px; }
            .button { padding: 10px 20px; font-size: 13px; }
            #start-screen h2, #game-over-screen h2, #pause-screen h2 { font-size: 20px; }
        }
    </style>
</head>
<body>
    <div id="game-container" role="main">
        <div id="bird" role="img" aria-label="Flappy Bird"></div>
        <div id="score" aria-live="polite">Score: 0</div>
        <div id="scoreboard" aria-live="polite">Pipes: 0</div>
        <button id="pause-button" onclick="togglePause()" aria-label="Pause Game">Pause</button>
        <div id="notification" aria-live="assertive"></div>

        <div id="start-screen" role="dialog" aria-label="Start Menu">
            <h2>Flappy Bird</h2>
            <div id="leaderboard">Loading High Scores...</div>
            <div id="achievements">Loading Achievements...</div>
            <div id="tips">Controls: Spacebar, Mouse Click, or Touch to jump. Ctrl+P or Esc to pause/resume. Avoid pipes! Collect yellow power-ups for temporary invincibility!</div>
            <div class="button-group">
                <button class="button" id="easy-btn" onclick="startGame('easy')" tabindex="0">Easy</button>
                <button class="button" id="medium-btn" onclick="startGame('medium')" tabindex="0">Medium</button>
                <button class="button" id="hard-btn" onclick="startGame('hard')" tabindex="0">Hard</button>
                <button class="button" id="nightmare-btn" onclick="startGame('nightmare')" style="display: none;" tabindex="0">Nightmare</button>
            </div>
            <button class="button" onclick="resetHighScores()" style="background: linear-gradient(45deg, #888, #666); margin-top: 20px;" tabindex="0">Reset Scores</button>
        </div>

        <div id="pause-screen" role="dialog" aria-label="Pause Menu">
            <h2>Paused</h2>
            <div id="pause-score" aria-live="polite">Score: 0</div>
            <div class="button-group">
                <button class="button" onclick="togglePause()" tabindex="0">Resume</button>
                <button class="button" onclick="retryGame()" tabindex="0">Restart</button>
                <button class="button" onclick="quitToMenu()" tabindex="0">Menu</button>
            </div>
        </div>

        <div id="game-over-screen" role="dialog" aria-label="Game Over Menu">
            <h2>Game Over</h2>
            <div id="final-score" aria-live="polite">Final Score: 0</div>
            <div class="button-group">
                <button class="button" onclick="retryGame()" tabindex="0">Retry</button>
                <button class="button" onclick="quitToMenu()" style="background: linear-gradient(45deg, #aaa, #888);" tabindex="0">Menu</button>
            </div>
        </div>
    </div>

    <audio id="jump-sound" src="jump.mp3" preload="auto"></audio>
    <audio id="pipe-sound" src="pipe.mp3" preload="auto"></audio>
    <audio id="game-over-sound" src="gameover.mp3" preload="auto"></audio>
    <audio id="power-up-sound" src="powerup.mp3" preload="auto"></audio>
    <audio id="bg-music" src="bgmusic.mp3" loop preload="auto"></audio>

    <script>
        const gameContainer = document.getElementById('game-container');
        const bird = document.getElementById('bird');
        const scoreDisplay = document.getElementById('score');
        const scoreboard = document.getElementById('scoreboard');
        const pauseButton = document.getElementById('pause-button');
        const startScreen = document.getElementById('start-screen');
        const pauseScreen = document.getElementById('pause-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScore = document.getElementById('final-score');
        const leaderboard = document.getElementById('leaderboard');
        const achievementsDisplay = document.getElementById('achievements');
        const notification = document.getElementById('notification');
        const nightmareBtn = document.getElementById('nightmare-btn');
        const pauseScore = document.getElementById('pause-score');
        const jumpSound = document.getElementById('jump-sound');
        const pipeSound = document.getElementById('pipe-sound');
        const gameOverSound = document.getElementById('game-over-sound');
        const powerUpSound = document.getElementById('power-up-sound');
        const bgMusic = document.getElementById('bg-music');

        let birdY = 280;
        let velocity = 0;
        let score = 0;
        let pipeCount = 0;
        let pipes = [];
        let clouds = [];
        let powerUps = [];
        let trails = [];
        let gameOver = false;
        let gameStarted = false;
        let isPaused = false;
        let levelConfig = {};
        let pipeSpawnInterval;
        let cloudSpawnInterval;
        let powerUpSpawnInterval;
        let gameLoopId;
        let multiplier = 1;
        let isTutorial = !localStorage.getItem('hasPlayed');
        let lastMilestoneScore = 0;
        let isInvincible = false;
        let invincibilityTimer = null;

        const BIRD_SIZE = 40;
        const POWERUP_SIZE = 30;
        const PIPE_WIDTHS = [50, 60, 70];
        const MIN_HORIZONTAL_GAP = 250;
        const MAX_HORIZONTAL_GAP = 350;

        // Updated levels with decreasing verticalGap and slightly increasing baseSpeed
        const levels = {
            easy:      { gravity: 0.6, jump: -10, baseSpeed: 3.0, pipeFreq: 2000, powerUpChance: 0.15, verticalGap: 180 },
            medium:    { gravity: 0.7, jump: -11, baseSpeed: 3.5, pipeFreq: 1800, powerUpChance: 0.20, verticalGap: 160 },
            hard:      { gravity: 0.8, jump: -12, baseSpeed: 4.0, pipeFreq: 1600, powerUpChance: 0.25, verticalGap: 140 },
            nightmare: { gravity: 0.9, jump: -13, baseSpeed: 4.5, pipeFreq: 1500, powerUpChance: 0.30, verticalGap: 120 }
        };

        const GAME_WIDTH = () => gameContainer.clientWidth;
        const GAME_HEIGHT = () => gameContainer.clientHeight;

        let highScores = JSON.parse(localStorage.getItem('flappyHighScores')) || { easy: 0, medium: 0, hard: 0, nightmare: 0 };
        let achievements = JSON.parse(localStorage.getItem('achievements')) || [];

        function updateLeaderboard() {
            leaderboard.innerHTML = `<h3>High Scores:</h3>Easy: ${highScores.easy}<br>Medium: ${highScores.medium}<br>Hard: ${highScores.hard}<br>Nightmare: ${highScores.nightmare}`;
            nightmareBtn.style.display = highScores.hard >= 40 ? 'inline-block' : 'none';
            achievementsDisplay.innerHTML = `<h3>Achievements:</h3>${achievements.length > 0 ? achievements.join(', ') : 'None yet!'}`;
        }

        function resetHighScores() {
            if (confirm("Are you sure you want to reset all scores and achievements?")) {
                highScores = { easy: 0, medium: 0, hard: 0, nightmare: 0 };
                achievements = [];
                localStorage.setItem('flappyHighScores', JSON.stringify(highScores));
                localStorage.setItem('achievements', JSON.stringify(achievements));
                localStorage.removeItem('hasPlayed');
                isTutorial = true;
                updateLeaderboard();
                showNotification("Scores and Achievements Reset!");
            }
        }

        function showNotification(message) {
            notification.textContent = message;
            notification.style.display = 'block';
            if (notification.timeoutId) clearTimeout(notification.timeoutId);
            notification.timeoutId = setTimeout(() => {
                notification.style.display = 'none';
                notification.timeoutId = null;
            }, 3000);
        }

        function startGame(level) {
            if (!levels[level]) return;

            levelConfig = { ...levels[level], name: level };
            document.body.className = level; // Set difficulty class for pipe colors
            birdY = GAME_HEIGHT() * 0.4667;
            velocity = 0;
            score = 0;
            pipeCount = 0;
            multiplier = 1;
            lastMilestoneScore = 0;
            gameOver = false;
            isPaused = false;
            gameStarted = true;
            isInvincible = false;
            if (invincibilityTimer) clearTimeout(invincibilityTimer);
            bird.classList.remove('invincible');

            clearGameElements();

            scoreDisplay.textContent = `Score: ${score}`;
            scoreboard.textContent = `Pipes: ${pipeCount}`;
            bird.style.top = birdY + 'px';
            bird.style.transform = 'rotate(0deg)';
            bird.style.display = 'block';
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            pauseScreen.style.display = 'none';
            pauseButton.textContent = 'Pause';
            pauseButton.style.display = 'block';

            clearInterval(pipeSpawnInterval);
            clearInterval(cloudSpawnInterval);
            clearInterval(powerUpSpawnInterval);
            cancelAnimationFrame(gameLoopId);

            pipeSpawnInterval = setInterval(createPipePair, levelConfig.pipeFreq);
            cloudSpawnInterval = setInterval(createCloud, 5000);
            powerUpSpawnInterval = setInterval(spawnPowerUp, 4000);

            bgMusic.currentTime = 0;
            bgMusic.play().catch(e => console.warn('Background music autoplay failed:', e));

            gameLoop();

            if (isTutorial) {
                localStorage.setItem('hasPlayed', 'true');
                isTutorial = false;
            }
        }

        function clearGameElements() {
            pipes.forEach(pipe => pipe.element.remove());
            pipes = [];
            clouds.forEach(cloud => cloud.element.remove());
            clouds = [];
            powerUps.forEach(p => p.element.remove());
            powerUps = [];
            trails.forEach(t => t.remove());
            trails = [];
            gameContainer.querySelectorAll('.pipe, .cloud, .power-up, .trail').forEach(el => el.remove());
        }

        function updateBird() {
            if (!gameStarted || gameOver || isPaused) return;

            const gameHeight = GAME_HEIGHT();
            const dynamicGravity = Math.min(levelConfig.gravity + (score * 0.001), levelConfig.gravity * 1.5);
            velocity += dynamicGravity;
            birdY += velocity;

            birdY = Math.max(0, Math.min(birdY, gameHeight - BIRD_SIZE));
            bird.style.top = birdY + 'px';

            const rotation = Math.max(-30, Math.min(velocity * 3, 90));
            bird.style.transform = `rotate(${rotation}deg)`;

            if (birdY <= 0 || birdY >= gameHeight - BIRD_SIZE) {
                endGame();
                return;
            }

            if (Math.random() < 0.15) createTrail();
        }

        function createTrail() {
            if (trails.length > 10) {
                const oldestTrail = trails.shift();
                if (oldestTrail) oldestTrail.remove();
            }

            const trail = document.createElement('div');
            trail.className = 'trail';
            trail.style.left = (bird.offsetLeft + BIRD_SIZE / 2 - 4) + 'px';
            trail.style.top = (bird.offsetTop + BIRD_SIZE / 2 - 4) + 'px';
            gameContainer.appendChild(trail);
            trails.push(trail);

            setTimeout(() => {
                const index = trails.indexOf(trail);
                if (index > -1) trails.splice(index, 1);
                trail.remove();
            }, 500);
        }

        function createPipePair() {
            if (!gameStarted || gameOver || isPaused) return;

            const gameHeight = GAME_HEIGHT();
            const gameWidth = GAME_WIDTH();
            const pipeWidth = PIPE_WIDTHS[Math.floor(Math.random() * PIPE_WIDTHS.length)];
            const currentVerticalGap = levelConfig.verticalGap; // Now varies by level

            const minTopHeight = 50;
            const maxTopHeight = gameHeight - currentVerticalGap - minTopHeight;
            const topPipeHeight = Math.floor(Math.random() * (maxTopHeight - minTopHeight)) + minTopHeight;
            const bottomPipeHeight = gameHeight - topPipeHeight - currentVerticalGap;

            let startX = gameWidth;
            if (pipes.length > 0) {
                const lastPipe = pipes[pipes.length - 1];
                const lastPairX = lastPipe.x;
                const complexityFactor = Math.min(score / 100, 0.5);
                const horizontalGap = MIN_HORIZONTAL_GAP + (Math.random() * (MAX_HORIZONTAL_GAP - MIN_HORIZONTAL_GAP) * (1 - complexityFactor));
                startX = Math.max(startX, lastPairX + pipeWidth + horizontalGap);
            }

            const topPipe = document.createElement('div');
            topPipe.className = 'pipe pipe-top';
            topPipe.style.height = topPipeHeight + 'px';
            topPipe.style.width = pipeWidth + 'px';
            topPipe.style.left = startX + 'px';
            topPipe.style.top = '0px';
            gameContainer.appendChild(topPipe);
            pipes.push({ element: topPipe, x: startX, y: 0, height: topPipeHeight, width: pipeWidth, isTop: true, passed: false });

            const bottomPipe = document.createElement('div');
            bottomPipe.className = 'pipe pipe-bottom';
            bottomPipe.style.height = bottomPipeHeight + 'px';
            bottomPipe.style.width = pipeWidth + 'px';
            bottomPipe.style.left = startX + 'px';
            bottomPipe.style.bottom = '0px';
            gameContainer.appendChild(bottomPipe); // Fixed typo: customPipe -> bottomPipe
            const bottomPipeY = gameHeight - bottomPipeHeight;
            pipes.push({ element: bottomPipe, x: startX, y: bottomPipeY, height: bottomPipeHeight, width: pipeWidth, isTop: false, passed: false });
        }

        function createCloud() {
            if (clouds.length > 5 || Math.random() > 0.4) return;

            const cloud = document.createElement('div');
            cloud.className = 'cloud';
            const gameWidth = GAME_WIDTH();
            cloud.style.left = gameWidth + 'px';
            cloud.style.top = (Math.random() * (GAME_HEIGHT() * 0.6)) + 'px';
            const scale = 0.8 + Math.random() * 0.7;
            cloud.style.transform = `scale(${scale})`;
            cloud.style.opacity = 0.5 + Math.random() * 0.3;
            gameContainer.appendChild(cloud);
            clouds.push({ element: cloud, x: gameWidth, speedFactor: 0.3 + Math.random() * 0.4 });
        }

        function doesYOverlapWithPipes(yPosition, targetX) {
            const powerUpRadius = POWERUP_SIZE / 2;
            const powerUpTop = yPosition;
            const powerUpBottom = yPosition + POWERUP_SIZE;

            for (const pipe of pipes) {
                if (pipe.x < targetX + 100 && pipe.x + pipe.width > targetX - 100) {
                    const pipeTop = pipe.y;
                    const pipeBottom = pipe.y + pipe.height;
                    if (powerUpTop < pipeBottom && powerUpBottom > pipeTop) return true;
                }
            }
            return false;
        }

        function spawnPowerUp() {
            if (!gameStarted || gameOver || isPaused || powerUps.length > 0 || Math.random() > levelConfig.powerUpChance) return;

            const gameHeight = GAME_HEIGHT();
            const gameWidth = GAME_WIDTH();
            const spawnX = gameWidth + 50;
            const minY = gameHeight * 0.2;
            const maxY = gameHeight * 0.8 - POWERUP_SIZE;

            let attempts = 0;
            const maxAttempts = 5;

            while (attempts < maxAttempts) {
                const spawnY = Math.random() * (maxY - minY) + minY;
                if (!doesYOverlapWithPipes(spawnY, spawnX)) {
                    const powerUp = document.createElement('div');
                    powerUp.className = 'power-up';
                    powerUp.style.left = spawnX + 'px';
                    powerUp.style.top = spawnY + 'px';
                    gameContainer.appendChild(powerUp);
                    powerUps.push({ element: powerUp, x: spawnX, y: spawnY, type: 'invincible' });
                    return;
                }
                attempts++;
            }
        }

        function updateObstacles() {
            if (isPaused || gameOver) return;

            const scoreBonus = Math.floor(score / 50) * (levelConfig.baseSpeed * 0.05);
            const dynamicSpeed = Math.min(levelConfig.baseSpeed + scoreBonus, levelConfig.baseSpeed * 2);

            bgMusic.playbackRate = Math.min(1 + (dynamicSpeed - levels.easy.baseSpeed) * 0.1, 1.5);

            const birdRect = bird.getBoundingClientRect();
            const gameRect = gameContainer.getBoundingClientRect();
            const birdRadius = BIRD_SIZE * 0.4;
            const birdCenterX = (birdRect.left - gameRect.left) + birdRect.width / 2;
            const birdCenterY = (birdRect.top - gameRect.top) + birdRect.height / 2;

            for (let i = pipes.length - 1; i >= 0; i--) {
                const pipe = pipes[i];
                pipe.x -= dynamicSpeed;
                pipe.element.style.left = pipe.x + 'px';

                if (!isInvincible && checkCollision(birdCenterX, birdCenterY, birdRadius, pipe)) {
                    endGame();
                    return;
                }

                if (!pipe.passed && pipe.isTop && birdCenterX > pipe.x + pipe.width) {
                    pipe.passed = true;
                    const bottomPipe = pipes.find(p => p.x === pipe.x && !p.isTop);
                    if (bottomPipe) bottomPipe.passed = true;

                    pipeCount++;
                    multiplier = pipeCount >= 50 ? 4 : pipeCount >= 25 ? 3 : pipeCount >= 10 ? 2 : 1;
                    score += multiplier;

                    if (score > 0 && score >= lastMilestoneScore + 100) {
                        lastMilestoneScore = Math.floor(score / 100) * 100;
                        showNotification(`Score Milestone: ${lastMilestoneScore}!`);
                    }

                    scoreDisplay.textContent = `Score: ${score}`;
                    scoreboard.textContent = `Pipes: ${pipeCount}`;
                    pipeSound.play().catch(e => console.warn('Pipe sound failed:', e));
                    checkAchievements();
                    updateBackground();
                }

                if (pipe.x + pipe.width < 0) {
                    pipe.element.remove();
                    pipes.splice(i, 1);
                }
            }

            for (let i = clouds.length - 1; i >= 0; i--) {
                const cloud = clouds[i];
                cloud.x -= dynamicSpeed * cloud.speedFactor;
                cloud.element.style.left = cloud.x + 'px';
                const cloudWidth = cloud.element.offsetWidth;
                if (cloud.x + cloudWidth < 0) {
                    cloud.element.remove();
                    clouds.splice(i, 1);
                }
            }

            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                powerUp.x -= dynamicSpeed;
                powerUp.element.style.left = powerUp.x + 'px';

                const powerUpCenterX = powerUp.x + POWERUP_SIZE / 2;
                const powerUpCenterY = powerUp.y + POWERUP_SIZE / 2;
                const dx = birdCenterX - powerUpCenterX;
                const dy = birdCenterY - powerUpCenterY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < birdRadius + POWERUP_SIZE / 2) {
                    powerUpSound.play().catch(e => console.warn('Power-up sound failed:', e));
                    applyPowerUp(powerUp.type);
                    powerUp.element.remove();
                    powerUps.splice(i, 1);
                } else if (powerUp.x + POWERUP_SIZE < 0) {
                    powerUp.element.remove();
                    powerUps.splice(i, 1);
                }
            }
        }

        function checkCollision(birdX, birdY, birdR, pipe) {
            const closestX = Math.max(pipe.x, Math.min(birdX, pipe.x + pipe.width));
            const closestY = Math.max(pipe.y, Math.min(birdY, pipe.y + pipe.height));
            const distX = birdX - closestX;
            const distY = birdY - closestY;
            const distanceSquared = (distX * distX) + (distY * distY);
            return distanceSquared < (birdR * birdR);
        }

        function applyPowerUp(type) {
            if (type === 'invincible' && !isInvincible) {
                isInvincible = true;
                bird.classList.add('invincible');
                showNotification("Invincible!");
                if (invincibilityTimer) clearTimeout(invincibilityTimer);
                invincibilityTimer = setTimeout(() => {
                    isInvincible = false;
                    bird.classList.remove('invincible');
                    showNotification("Invincibility Wore Off!");
                    invincibilityTimer = null;
                }, 5000);
            }
        }

        function checkAchievements() {
            let newAchievement = false;
            const achieve = (name) => {
                if (!achievements.includes(name)) {
                    achievements.push(name);
                    showNotification(`Achievement: ${name}!`);
                    newAchievement = true;
                }
            };

            if (pipeCount >= 10) achieve('First 10 Pipes');
            if (pipeCount >= 25) achieve('25 Pipes');
            if (pipeCount >= 50) achieve('Pipe Master (50)');
            if (pipeCount >= 100) achieve('Pipe Century (100)');
            if (score >= 50) achieve('Score 50+');
            if (score >= 100) achieve('Score 100+');
            if (score >= 200) achieve('Score 200+');
            if (levelConfig.name === 'hard' && score >= 30) achieve('Hard Mode Pro');
            if (levelConfig.name === 'nightmare' && pipeCount >= 1) achieve('Facing the Nightmare');
            if (levelConfig.name === 'nightmare' && score >= 25) achieve('Nightmare Survivor');

            if (newAchievement) {
                localStorage.setItem('achievements', JSON.stringify(achievements));
                updateLeaderboard();
            }
        }

        function updateBackground() {
            const hue = (score * 5) % 360;
            gameContainer.style.backgroundColor = `hsl(${hue}, 60%, 70%)`;
        }

        function jump() {
            if (!gameStarted || gameOver || isPaused) return;
            velocity = levelConfig.jump;
            jumpSound.play().catch(e => console.warn('Jump sound failed:', e));
            bird.style.transform = `rotate(-30deg)`;
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'ArrowUp') {
                e.preventDefault();
                jump();
            } else if ((e.ctrlKey || e.metaKey) && e.code === 'KeyP') {
                e.preventDefault();
                togglePause();
            } else if (e.code === 'Escape' && gameStarted && !gameOver) {
                e.preventDefault();
                togglePause();
            }
        });

        function gameLoop(timestamp) {
            if (gameOver) return;
            if (!isPaused) {
                updateBird();
                if (!gameOver) updateObstacles();
            }
            if (!gameOver) gameLoopId = requestAnimationFrame(gameLoop);
        }

        function togglePause() {
            if (!gameStarted || gameOver) return;

            isPaused = !isPaused;
            pauseButton.textContent = isPaused ? 'Resume' : 'Pause';
            pauseScreen.style.display = isPaused ? 'flex' : 'none';

            if (isPaused) {
                pauseScore.textContent = `Score: ${score}`;
                bgMusic.pause();
                clearInterval(pipeSpawnInterval);
                clearInterval(cloudSpawnInterval);
                clearInterval(powerUpSpawnInterval);
                if (invincibilityTimer) clearTimeout(invincibilityTimer);
            } else {
                bgMusic.play().catch(e => console.warn('BG music resume failed:', e));
                pipeSpawnInterval = setInterval(createPipePair, levelConfig.pipeFreq);
                cloudSpawnInterval = setInterval(createCloud, 5000);
                powerUpSpawnInterval = setInterval(spawnPowerUp, 4000);
                requestAnimationFrame(gameLoop);
            }
        }

        function endGame() {
            if (gameOver) return;

            gameOver = true;
            gameStarted = false;
            isInvincible = false;
            if (invincibilityTimer) clearTimeout(invincibilityTimer);
            bird.classList.remove('invincible');

            clearInterval(pipeSpawnInterval);
            clearInterval(cloudSpawnInterval);
            clearInterval(powerUpSpawnInterval);
            cancelAnimationFrame(gameLoopId);

            gameOverSound.play().catch(e => console.warn('Game over sound failed:', e));
            bgMusic.pause();

            gameOverScreen.style.display = 'flex';
            finalScore.textContent = `Final Score: ${score}`;
            pauseButton.style.display = 'none';

            const currentLevel = levelConfig.name || 'easy';
            if (score > (highScores[currentLevel] || 0)) {
                highScores[currentLevel] = score;
                localStorage.setItem('flappyHighScores', JSON.stringify(highScores));
                updateLeaderboard();
                showNotification(`New High Score for ${currentLevel.charAt(0).toUpperCase() + currentLevel.slice(1)}!`);
            }
        }

        function retryGame() {
            gameOverScreen.style.display = 'none';
            pauseScreen.style.display = 'none';
            cancelAnimationFrame(gameLoopId);
            const levelName = levelConfig.name;
            if (levelName && levels[levelName]) startGame(levelName);
            else {
                quitToMenu();
                showNotification("Error restarting. Returning to menu.");
            }
        }

        function quitToMenu() {
            if (gameStarted || isPaused || gameOver) {
                gameOver = true;
                gameStarted = false;
                isPaused = false;
                isInvincible = false;
                if (invincibilityTimer) clearTimeout(invincibilityTimer);
                bird.classList.remove('invincible');
                cancelAnimationFrame(gameLoopId);
                clearInterval(pipeSpawnInterval);
                clearInterval(cloudSpawnInterval);
                clearInterval(powerUpSpawnInterval);
                bgMusic.pause();
                bgMusic.currentTime = 0;
            }

            clearGameElements();
            bird.style.display = 'none';
            gameContainer.style.backgroundColor = '#87CEEB';
            pauseButton.textContent = 'Pause';
            pauseButton.style.display = 'none';
            lastMilestoneScore = 0;
            document.body.className = ''; // Reset difficulty class

            gameOverScreen.style.display = 'none';
            pauseScreen.style.display = 'none';
            startScreen.style.display = 'flex';
            updateLeaderboard();
        }

        window.addEventListener('load', () => {
            updateLeaderboard();
            bird.style.display = 'none';
            pauseButton.style.display = 'none';
            bgMusic.play().catch(e => console.warn('Background music autoplay failed on load:', e));
            birdY = GAME_HEIGHT() * 0.4667;
            bird.style.top = birdY + 'px';
            adjustGameSize();
        });

        (function enhanceTouchSupport() {
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

            function handleJumpEvent(e) {
                if (!gameStarted || gameOver || isPaused || e.target.closest('button')) return;
                e.preventDefault();
                jump();
            }

            if (isTouchDevice) {
                gameContainer.addEventListener('touchstart', handleJumpEvent, { passive: false });
                gameContainer.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
            } else {
                gameContainer.addEventListener('mousedown', handleJumpEvent);
            }
            gameContainer.addEventListener('contextmenu', e => e.preventDefault());
        })();

        function adjustGameSize() {
            const maxWidth = 800;
            const maxHeight = 600;
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            const targetAspectRatio = maxWidth / maxHeight;
            const windowAspectRatio = windowWidth / windowHeight;

            let gameWidth = windowAspectRatio > targetAspectRatio
                ? Math.min(maxWidth, windowHeight * 0.9 * targetAspectRatio)
                : Math.min(maxWidth, windowWidth * 0.9);
            let gameHeight = gameWidth / targetAspectRatio;

            if (gameHeight > maxHeight) {
                gameHeight = maxHeight;
                gameWidth = gameHeight * targetAspectRatio;
            }

            gameContainer.style.width = `${gameWidth}px`;
            gameContainer.style.height = `${gameHeight}px`;

            if (!gameStarted) {
                birdY = GAME_HEIGHT() * 0.4667;
                bird.style.top = birdY + 'px';
            }
        }
        window.addEventListener('resize', adjustGameSize);
        window.addEventListener('orientationchange', adjustGameSize);

        (function handleAudioCompatibility() {
            const audioElements = [bgMusic, jumpSound, pipeSound, gameOverSound, powerUpSound];
            let audioUnlocked = false;

            function unlockAudio() {
                if (audioUnlocked) return;
                audioElements.forEach(audio => {
                    audio.play().then(() => audio.pause()).catch(() => {});
                    audio.currentTime = 0;
                });
                audioUnlocked = true;
                console.log('Audio context unlocked.');
                document.removeEventListener('touchstart', unlockAudio);
                document.removeEventListener('click', unlockAudio);
                document.removeEventListener('keydown', unlockAudio);
                if (!gameStarted && !isPaused && !gameOver) {
                    bgMusic.play().catch(e => console.warn("BG music still couldn't play after unlock:", e));
                }
            }

            document.addEventListener('touchstart', unlockAudio, { once: true, passive: true });
            document.addEventListener('click', unlockAudio, { once: true, passive: true });
            document.addEventListener('keydown', unlockAudio, { once: true, passive: true });

            audioElements.forEach(audio => {
                const originalPlay = audio.play;
                audio.play = function() {
                    if (audio.paused) {
                        const playPromise = originalPlay.call(this);
                        if (playPromise !== undefined) {
                            return playPromise.catch(error => {
                                if (error.name !== 'NotAllowedError') console.warn(`Audio play failed for ${audio.id}:`, error);
                            });
                        }
                    }
                    return Promise.resolve();
                };
            });
        })();

        (function addFullscreenSupport() {
            const fsEnabled = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
            if (!fsEnabled) return;

            const fullscreenBtnProto = document.createElement('button');
            fullscreenBtnProto.textContent = 'Fullscreen';
            fullscreenBtnProto.className = 'button';
            fullscreenBtnProto.style.background = 'linear-gradient(45deg, #4CAF50, #45a049)';
            fullscreenBtnProto.style.marginTop = '10px';

            function toggleFullscreen() {
                if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
                    const requestMethod = gameContainer.requestFullscreen || gameContainer.webkitRequestFullscreen || gameContainer.mozRequestFullScreen || gameContainer.msRequestFullscreen;
                    if (requestMethod) requestMethod.call(gameContainer).catch(err => console.warn('Fullscreen request failed:', err));
                } else {
                    const exitMethod = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
                    if (exitMethod) exitMethod.call(document);
                }
            }

            [startScreen, pauseScreen, gameOverScreen].forEach(screen => {
                const buttons = screen.querySelector('.button-group') || screen;
                buttons.appendChild(fullscreenBtnProto.cloneNode(true)).addEventListener('click', toggleFullscreen);
            });

            function handleFullscreenChange() {
                const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
                gameContainer.style.border = isFullscreen ? 'none' : '10px solid #5a4b3c';
                gameContainer.style.borderRadius = isFullscreen ? '0' : '20px';
                adjustGameSize();
            }

            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        })();

        console.log('Flappy Bird loaded successfully.');
    </script>
</body>
    </html>
